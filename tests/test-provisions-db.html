<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Provisions-System DB Test</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #eee; }
        .test { margin: 10px 0; padding: 10px; border-radius: 4px; }
        .pass { background: #0f5132; border: 1px solid #0a3622; }
        .fail { background: #842029; border: 1px solid #5c1319; }
        .info { background: #084298; border: 1px solid #052c65; }
        h1, h2 { color: #fff; }
        pre { background: #0d1117; padding: 10px; overflow-x: auto; border-radius: 4px; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #444; padding: 8px; text-align: left; }
        th { background: #333; }
        button { background: #0d6efd; color: white; border: none; padding: 10px 20px; cursor: pointer; border-radius: 4px; margin: 5px; }
        button:hover { background: #0b5ed7; }
    </style>
</head>
<body>
    <h1>üîç Ledger-System Datenbank-Test</h1>
    <p>Neues EH-basiertes Ledger-System (provisions_ledger + customer_billing_ledger)</p>

    <button onclick="runAllTests()">Alle Tests ausf√ºhren</button>

    <div id="results"></div>

    <script>
        const SUPABASE_URL = 'https://lgztglycqtiwcmiydxnm.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxnenRnbHljcXRpd2NtaXlkeG5tIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2MzgwNzYxNSwiZXhwIjoyMDc5MzgzNjE1fQ.54kSk9ZSUdQt6LKYWkblqgR6Sjev80W80qkNHYEbPgk';

        const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        const results = document.getElementById('results');

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `test ${type}`;
            div.innerHTML = message;
            results.appendChild(div);
        }

        function logTable(title, data, columns) {
            let html = `<h3>${title}</h3>`;
            if (!data || data.length === 0) {
                html += '<p>Keine Daten</p>';
            } else {
                html += '<table><tr>';
                columns.forEach(col => html += `<th>${col}</th>`);
                html += '</tr>';
                data.forEach(row => {
                    html += '<tr>';
                    columns.forEach(col => html += `<td>${row[col] ?? '-'}</td>`);
                    html += '</tr>';
                });
                html += '</table>';
            }
            log(html, 'info');
        }

        async function runAllTests() {
            results.innerHTML = '';
            log('<h2>üöÄ Starte Tests...</h2>');

            // Test 1: Tabelle existiert und hat Daten
            await test1_tabelleExistiert();

            // Test 2: Beispiel-Daten anzeigen
            await test2_beispielDaten();

            // Test 3: Trigger pr√ºfen
            await test3_triggerPruefen();

            // Test 4: invoice_positions Tabelle
            await test4_invoicePositions();

            // Test 5: provisions_ledger Tabelle (neues Schema)
            await test5_provisionsLedger();

            // Test 6: customer_billing_ledger Tabelle
            await test6_customerBillingLedger();

            log('<h2>‚úÖ Tests abgeschlossen</h2>');
        }

        async function test1_tabelleExistiert() {
            log('<h2>Test 1: Tabelle user_provision_settings</h2>');

            const { count, error } = await db
                .from('user_provision_settings')
                .select('*', { count: 'exact', head: true });

            if (error) {
                log(`‚ùå FEHLER: ${error.message}`, 'fail');
                return;
            }

            // Werber z√§hlen
            const { count: werberCount } = await db
                .from('users')
                .select('*', { count: 'exact', head: true })
                .eq('role', 'werber');

            log(`‚úÖ Tabelle existiert mit <strong>${count}</strong> Eintr√§gen (Werber: ${werberCount})`,
                count > 0 ? 'pass' : 'fail');
        }

        async function test2_beispielDaten() {
            log('<h2>Test 2: Beispiel-Daten</h2>');

            const { data, error } = await db
                .from('user_provision_settings')
                .select(`
                    user_id,
                    vorschuss_anteil,
                    stornorucklage_anteil,
                    tc_faktor,
                    tc_mind_eh,
                    empfehlung_faktor,
                    quality_faktor,
                    users!inner(name)
                `)
                .limit(10);

            if (error) {
                log(`‚ùå FEHLER: ${error.message}`, 'fail');
                return;
            }

            // Daten f√ºr Tabelle aufbereiten
            const tableData = data.map(d => ({
                name: d.users?.name || '-',
                vorschuss: d.vorschuss_anteil,
                storno: d.stornorucklage_anteil,
                tc_faktor: d.tc_faktor,
                tc_mind_eh: d.tc_mind_eh,
                empf_faktor: d.empfehlung_faktor,
                quality_faktor: d.quality_faktor
            }));

            logTable('Erste 10 Eintr√§ge', tableData,
                ['name', 'vorschuss', 'storno', 'tc_faktor', 'tc_mind_eh', 'empf_faktor', 'quality_faktor']);

            log('‚úÖ Daten erfolgreich geladen', 'pass');
        }

        async function test3_triggerPruefen() {
            log('<h2>Test 3: Trigger pr√ºfen</h2>');

            // Wir k√∂nnen Trigger nicht direkt √ºber die API abfragen
            // Stattdessen testen wir die Synchronisation
            log('‚ÑπÔ∏è Trigger k√∂nnen nur √ºber SQL Editor in Supabase gepr√ºft werden:', 'info');
            log(`<pre>SELECT tgname, tgrelid::regclass
FROM pg_trigger
WHERE tgname LIKE '%provision%' OR tgname LIKE '%sync%';</pre>`, 'info');

            log('Erwartete Trigger: ~5 (sync_profiles_to_provision, sync_provision_to_profiles, etc.)', 'info');
        }

        async function test4_invoicePositions() {
            log('<h2>Test 4: invoice_positions Tabelle</h2>');

            const { data, error, count } = await db
                .from('invoice_positions')
                .select('*', { count: 'exact' })
                .limit(5);

            if (error) {
                log(`‚ùå Tabelle nicht gefunden oder Fehler: ${error.message}`, 'fail');
                return;
            }

            log(`‚úÖ Tabelle existiert mit <strong>${count}</strong> Eintr√§gen`, 'pass');

            if (data && data.length > 0) {
                // Typen gruppieren
                const { data: typStats } = await db
                    .from('invoice_positions')
                    .select('typ');

                const typCounts = {};
                (typStats || []).forEach(t => {
                    typCounts[t.typ] = (typCounts[t.typ] || 0) + 1;
                });

                log(`Positions-Typen: ${JSON.stringify(typCounts)}`, 'info');
            }
        }

        async function test5_provisionsLedger() {
            log('<h2>Test 5: provisions_ledger (neues EH-Schema)</h2>');

            const { data, error, count } = await db
                .from('provisions_ledger')
                .select('*', { count: 'exact' })
                .limit(5);

            if (error) {
                log(`‚ùå Tabelle nicht gefunden oder Fehler: ${error.message}`, 'fail');
                return;
            }

            log(`‚úÖ Tabelle existiert mit <strong>${count}</strong> Eintr√§gen`, 'pass');

            // Schema pr√ºfen (neue Spalten)
            if (data && data.length > 0) {
                const requiredCols = ['user_id', 'kategorie', 'typ', 'einheiten', 'kw', 'year', 'referenz_datum'];
                const firstRow = data[0];
                const missingCols = requiredCols.filter(col => !(col in firstRow));

                if (missingCols.length > 0) {
                    log(`‚ùå Fehlende Spalten im neuen Schema: ${missingCols.join(', ')}`, 'fail');
                } else {
                    log(`‚úÖ Neues Schema korrekt (einheiten, kw, year, etc.)`, 'pass');
                }

                // Beispiel-Daten anzeigen
                const tableData = data.map(d => ({
                    kategorie: d.kategorie,
                    typ: d.typ,
                    einheiten: d.einheiten,
                    kw: d.kw,
                    year: d.year
                }));
                logTable('Beispiel-Eintr√§ge (neu)', tableData, ['kategorie', 'typ', 'einheiten', 'kw', 'year']);
            }

            // Kategorien & Typen gruppieren
            const { data: stats } = await db
                .from('provisions_ledger')
                .select('kategorie, typ');

            if (stats && stats.length > 0) {
                const katCounts = {};
                const typCounts = {};
                stats.forEach(s => {
                    katCounts[s.kategorie] = (katCounts[s.kategorie] || 0) + 1;
                    typCounts[s.typ] = (typCounts[s.typ] || 0) + 1;
                });

                log(`Kategorien: ${JSON.stringify(katCounts)}`, 'info');
                log(`Typen: ${JSON.stringify(typCounts)}`, 'info');
            }

            // EH-Summen pro Kategorie
            const { data: ehSums } = await db.rpc('get_eh_sums_by_kategorie');
            if (ehSums) {
                log(`EH-Summen: ${JSON.stringify(ehSums)}`, 'info');
            }
        }

        async function test6_customerBillingLedger() {
            log('<h2>Test 6: customer_billing_ledger (Kunden-Ledger)</h2>');

            const { data, error, count } = await db
                .from('customer_billing_ledger')
                .select('*', { count: 'exact' })
                .limit(5);

            if (error) {
                log(`‚ùå Tabelle nicht gefunden oder Fehler: ${error.message}`, 'fail');
                return;
            }

            log(`‚úÖ Tabelle existiert mit <strong>${count}</strong> Eintr√§gen`, 'pass');

            // Schema pr√ºfen
            if (data && data.length > 0) {
                const requiredCols = ['customer_id', 'typ', 'jahreseuros', 'kw', 'year', 'referenz_datum'];
                const firstRow = data[0];
                const missingCols = requiredCols.filter(col => !(col in firstRow));

                if (missingCols.length > 0) {
                    log(`‚ùå Fehlende Spalten: ${missingCols.join(', ')}`, 'fail');
                } else {
                    log(`‚úÖ Schema korrekt (jahreseuros, kw, year, etc.)`, 'pass');
                }

                // Beispiel-Daten anzeigen
                const tableData = data.map(d => ({
                    typ: d.typ,
                    jahreseuros: d.jahreseuros,
                    kw: d.kw,
                    year: d.year,
                    abgerechnet: d.invoice_id ? 'Ja' : 'Nein'
                }));
                logTable('Beispiel-Eintr√§ge', tableData, ['typ', 'jahreseuros', 'kw', 'year', 'abgerechnet']);
            }

            // Typ-Statistik
            const { data: typStats } = await db
                .from('customer_billing_ledger')
                .select('typ');

            if (typStats && typStats.length > 0) {
                const typCounts = {};
                typStats.forEach(t => {
                    typCounts[t.typ] = (typCounts[t.typ] || 0) + 1;
                });
                log(`Typen: ${JSON.stringify(typCounts)}`, 'info');
            }
        }

        // Auto-run on load
        window.onload = () => {
            log('Klicke auf "Alle Tests ausf√ºhren" um die Datenbank zu pr√ºfen.', 'info');
        };
    </script>
</body>
</html>
